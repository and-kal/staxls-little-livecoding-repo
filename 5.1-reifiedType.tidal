
-------------------------------------------------
--           part one                          --
--                                             --
--   relevant note channels                    --
--      1,2,3,4                                --
--                                             --
--     relevant CC channels                    --
--     1-24:                                   --
-- inspired by Mike Hodnick once again         --  
-- https://www.youtube.com/watch?v=E_8lIIg2iJQ --
-------------------------------------------------

let
  midiN chan = s "midi" # midichan (chan - 1) 
in d1 $ 
stack [
  every 6 (|+ n 2) $ slow 3 $ n (scale "chinese" "[21,22,24,27]" - 36) # midiN 4 # legato 2 -- ^ pad + grains  
  , ccv 120 # ccn 19 # s "midi" -- ^ reverb d/w 
  , ccv 100 # ccn 20 # s "midi" -- ^ reverb shimmer
  , ccv (segment 50 $ slow 5 $ range 25 50 $ tri) # ccn 21 # s "midi" -- ^ grain shimmer
] # cps(158/60/4)

hush

let 
  pattern = (
    -- ((segment 1 $ choose[(1/16),(1/8)..(1/1)]) ~>) $ 
    "{1 0 1 0 1 1 1 1 0 0 0 0 1 0 0 }%16") 
    -- :: Pattern Bool
  rest = 
    -- (slow "<1..5>" $ 
    "{1!7 0}%8"
    -- ) :: Pattern Bool
  hatsMask = (sometimes rev) $ "0 1 0 1"
  midiN chan = s "midi" # midichan (chan - 1) 
  ccDis chan val = ccv val # ccn chan # s "midi" 
  ccDisrand1 chan val1 val2 = 
    ccn chan 
    # ccv (segment 50 (range val1 val2 $ rand)) 
    # s "midi" -- ^ this one is for sending one random value per cycle
  ccSeg chan val = ccv (segment 50 $ val) # ccn chan # s "midi" 
  var1 = whenmod 50 45 (slow "[3!3 0.5]")
  var2 = whenmod 65 50 ((slow "6") . (ply 8))
  var3 = whenmod 40 35 ((linger (1/12)) . (0.5 ~>))
  var4 = whenmod 10 12 (fast (3/4))
in
d1
$ var4 
-- $ var3 $ var2 $ var1
$
mask rest
$
stack [
    mask pattern $ struct "1*8" $ note 0 # midiN 1 -- ^ kick
    , whenmod 11 9 (|+ ccv 127) $ ccDis 2 0 -- ^ kick ultracompression
    , ccDisrand1 3 60 127 -- ^ kick ultracompression
    -- , ccv "<20!7 100>" # ccn 3 # s "midi" -- kick OD transients
    -- , mask (inv pattern) $ struct "1*8" $ note 1 # midiN 1 -- ^ snare
    -- , sometimes (rev) $ struct "1*8" $ note "[2 3]" # midiN 1 -- ^ hats
    , degradeBy 0.75 $ mask hatsMask $ struct "1*4" $ note 4 # midiN 1 -- ^ fm
    -- , ccDisrand1 1 60 100
    -- , degradeBy 0.75 $ mask (inv hatsMask) $ struct "1*4" $ note 5 # midiN 1 -- ^ blib (CZ)
    -- , degradeBy 0.75 $ slow 2 $ note "[6|7]" # midiN 1 -- ^ Murakami 
    -- , slow 2 $ n (scale "chinese" "[0|2] [3|4] [3|5] [4|5]") # midiN "[2 3]" -- ^ jupiter + diva
]
  # cps(158/60/2)

hush

-------------------------------------------------
--           part two                          --
--                                             --
--   relevant note channels                    --
--      5,6,7,8                                --
--                                             --
--     relevant CC channels                    --
--     25-48:                                  --
-------------------------------------------------

let 
  midiN chan = s "midi" # midichan (chan - 1) 
  ccDis chan val = ccv val # ccn chan # s "midi" 
  ccDisrand1 chan val1 val2 = 
    ccn chan 
    # ccv (segment 50 (range val1 val2 $ rand)) 
    # s "midi" -- ^ this one is for sending one random value per cycle
  ccSeg chan val = ccv (segment 50 $ val) # ccn chan # s "midi" 
  basePat = "<0 [1 2] 2 [1 2 0] 1 2 [2 1]>*4"
  var1 = whenmod 36 33 (zoom (1/4, 4)) 
  var2 = whenmod 12 9 (fast "<1.25 1.5>")
  var3 = whenmod 50 45 ((slow 8) . (ply 8))
in
d2
$
-- var1
-- $
-- var2
-- $
-- var3
-- $
somecyclesBy (1/6) (rev)
$ 
stack [
  -- whenmod 42 38 (degradeBy 1)
  -- $
  -- n (fit 1 [0..2] basePat) # midiN 5 -- 0..2=kick + FX
  -- , 
  (0.5 <~) $ n "<~ 12 ~ 17>" # midiN 5 -- 12=snare
  , 
  whenmod 6 8 (fast (3/4))
  $ 
  every 3 rev $ n "[0!3 ~ 2!4]*2" # midiN 6 -- ^ hat
  -- ,
  -- whenmod 32 16 (|+ ccv 90) -- ^ add clicks half of the time
  -- $
  -- ccn 31 # ccv 0 # s "midi" 
  -- , ("[1|0]" <~) -- ^ introducing another randomness generator here, otherwise the two `choose` will always be in sync
  -- $
  -- ccn 27 # ccv (cycleChoose [0, 105]) # s "midi" -- ^ grain pitch
  -- , ccn 30 # ccv (cycleChoose [30, 120]) # s "midi" -- ^ grain freq
  -- ,
  -- n (scale "harmonicMajor" $ (unwrap $ fit 0 ["c'min9", "gs'min9", "fs'min9"] basePat)) # midiN 8 -- synth
  -- ,
  -- every 4 ((fast 4) . (|+ ccv (segment 32 $ range 10 127 $ rand))) $ ccn 43 # ccv 0 # s "midi" -- ^ grain freq
]
# cps (161/60/4)

hush

-------------------------------------------------
--           part three                        --
--                                             --
--   relevant note channels                    --
--      9,10,11,12                             --
--                                             --
--     relevant CC channels                    --
--     49-72:                                  --
-------------------------------------------------

let 
  midiN chan = s "midi" # midichan (chan - 1) 
  ccDis chan val = ccv val # ccn chan # s "midi" 
  ccSeg chan val = ccv (segment 50 $ val) # ccn chan # s "midi" 
  basePat = "~@2 1@3 0@5 1@5 ~@4 0@6 1 0@5 1@9 ~@3"
  bpm = (169/60/4)
  varBpm1 = [bpm*1.5, bpm/1.5]
  varBpm2 = [bpm, bpm*2]
  varBpm3 = [bpm, bpm*1.25]
in
d3 
$
-- every 2 ((rev) . (degradeBy 0))
-- $
whenmod 10 8 ((rev) . (fast "0.75 1.25"))
$ stack [
  -- struct basePat $ note (-24) # midiN 9 -- ^ kick
  -- , 
  struct (inv basePat) $ note (-22) # midiN 9 -- ^ clap
  , 
  note "-21" # midiN 9 -- ^ snare
  -- , note "-20*16" # midiN 9 -- ^ hat
  -- , ccDis "55" "<0!7 20 40 60 90 127>" -- ^ hat chorus mod
  -- , sometimesBy (1/32) rev $ struct (basePat) $ slow 12 $ (note (scale "lydianMinor" ("[1..12]"))) # midiN 10 -- ^ synth
  -- , 
  -- (|+ n (irand 10)) $ n "<~!3 -24>" # midiN 11 -- ^ fx
  -- , ccDis "[61,62]" "<10 40 60 120 90>" -- ^ fx fx
  ] 
-- # cps (slow 4 $ listToPat varBpm3)
# cps (bpm)

hush

-------------------------------------------------
--           part four                         --
--                                             --
--   relevant note channels                    --
--      13,14,15,16                            --
--                                             --
--     relevant CC channels                    --
--     73-96:                                  --
-------------------------------------------------

let 
  midiN chan = s "midi" # midichan (chan - 1) 
  ccDis chan val = ccv val # ccn chan # s "midi" 
  ccSeg chan val = ccv (segment 50 $ val) # ccn chan # s "midi" 
  ccDisrand1 chan val1 val2 = 
    ccn chan 
    # ccv (segment 50 (range val1 val2 $ rand)) 
    # s "midi" -- ^ this one is for sending one random value per cycle
  basePat = 
    -- stretch -- ^ degrades everything
    "{0 1!4 1!3 0 0/2 1 ~ 0/2 0 1!5 ~}%16"
  var1 = whenmod 26 21 ((plyWith 16 (|+ n 1)) . (slow "16 8")) 
  var2 = whenmod 34 31 ((plyWith 12 (|- n 1)) . (slow "6 12")) 
  var3 = every 8 (rev) 
  var4 = every 7 (zoom (0.25, 0.75)) 
  var5 = whenmod 18 16 (fast "1.5 1 1.5") 
in
d4 
$
-- qtrigger $
seqPLoop [
  -- pat 1 --
  (0,32, stack [ var3 $ var4 $ var5 $ (|- n 7) $ struct basePat $ n (scale "minPent" "[1,3,5,7,9]") # midiN 16 -- ^ saw
  , ccv "<0!3 127!2>" # ccn "91" # s "midi" -- ^ saw redux
  ])
  ,
  -- pat 2 --
  (0,0, var3 $ var4 $ var5 $ stack [
    var1 $ var2 $ sometimesBy (1/16) (|+ n "[4|5]") $ struct basePat $ n (-7) # midiN 13 -- ^ synth
    -- ,
    -- var1 $ var2 $ struct (inv basePat) $ n (0) # midiN 14 # legato 2 -- ^ kick
    -- , ccv "<0!2 40!2 115!2 127!2>" # ccn "[79,80]" # s "midi" -- ^ kick distort
    -- , ccSeg "81" (slow 12 $ range 50 127 $ saw) # s "midi" -- ^ kick tonality
    -- , 
    -- var1 $ n "0 ~!3 [-14 -13] ~!3" # midiN 15 -- ^ metal
  ])
]
# cps (175/60/4)

hush