WIPWIPWIP

-------------------------------------------------
--           part one                          --
--                                             --
--   relevant note channels                    --
--      1,2,3,4                                --
--                                             --
--     relevant CC channels                    --
--     99-102: fmpitch                         --
-- inspired by Mike Hodnick once again         --  
-- https://www.youtube.com/watch?v=E_8lIIg2iJQ --
-------------------------------------------------

let 
  pattern = (
    -- ((segment 1 $ choose[(1/16),(1/8)..(1/1)]) ~>) $ 
    "{1 0 1 0 1 1 1 1 0 0 0 0 1 0 0 }%8") 
    -- :: Pattern Bool
  rest = 
    -- (slow "<1 2 3 5 4>" $ 
    "{1!6 0}%8"
    -- ) :: Pattern Bool
  hatsMask = (sometimes rev) $ "0 1 0 1"
  midiN chan = s "midi" # midichan (chan - 1) 
  ccDis chan val = ccv val # ccn chan # s "midi" 
  ccDisrand1 chan val1 val2 = 
    ccn chan 
    # ccv (segment 50 (range val1 val2 $ rand)) 
    # s "midi" -- ^ this one is for sending one random value per cycle
  ccSeg chan val = ccv (segment 50 $ val) # ccn chan # s "midi" 
in
d1
$
fast 2
$
mask rest
$
while "[1 0!7]" (fast (3/4))
$
stack [
    mask pattern $ struct "1*8" $ note 0 # midiN 1 -- ^ kick
    , whenmod 30 25 (|+ ccv 127) $ ccDis 100 0 -- ^ kick ultracompression
    , mask (inv pattern) $ struct "1*8" $ note 1 # midiN 1 -- ^ snare
    , sometimes (rev) $ struct "1*8" $ note "[2 3]" # midiN 1 -- ^ hats
    , degradeBy 0.75 $ mask hatsMask $ struct "1*4" $ note 4 # midiN 1 -- ^ fm
    , ccDisrand1 99 60 100
    , degradeBy 0.75 $ mask (inv hatsMask) $ struct "1*4" $ note 5 # midiN 1 -- ^ blib
    , n (scale "minPent" "[0|2] [3|5]") # midiN "[2 3]" -- ^ jupiter + diva
    , n (scale "minPent" "0..7") # midiN 4 -- ^ bass 
]
  # cps(158/60/4)

  hush